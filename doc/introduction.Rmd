---
title: "Introduction to Basic SNP Analysis with snpR"
author: "William Hemstrom"
date: "February 14, 2019"
output: 
  rmarkdown::html_vignette:
    toc: TRUE
vignette: >
  %\VignetteIndexEntry{snpR_introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r include=FALSE}
library(snpR); library(ggplot2)
```

# snpR Introduction

snpR is a SNP genomic analysis package that is designed to do a range of basic genomic analyses, such as calculate observed and expected heterozygosity, linkage disequilibrium, pairwise-Fst, and so on. As much as possible is written using well-commented efficient, vectorized basic R, so that each individual function can be easily examined by the user if wanted.

# Quick-start Guide

Here, we will walk through a basic analysis of the example three-spined stickleback data included in this package. We will filter SNP data, make PCA and tSNE exploratory plots, calculate $\pi, observed heterozygosity, check for private alleles, calculate pairwise FST, gaussian smooth and plot these parameters, and then calculate pairwise LD in one population.

## Input Data format

snpR can take a variety of SNP data formats. The basic input format is a tab-delimited SNP dataset, where each row contains metadata and genotypes for a single SNP. Genotypes are noted with two characters, such as "GG" or "GA" for a G/G homozygote and a G/A heterozygote, respectively. The missing data format can be user-defined, but is "NN" by default. For example, see the stick_NN_input.txt distributed with this package (snpR/data/stick_NN_input.txt). Note that this is identical to the format output by, for example, the ANGSD software package. Ensure that genotypes are not stored as factors during import. The resulting data looks like:

```{r echo=FALSE}
print(head(stickSNPs)[,1:6], row.names = F)
```

Note that snpR can also import data where genotypes are stored as four numbers (ex. "GG", "GA", and "NN" as "0101", "0102", and "0000", respecitively), and as a single numeric character (homozygotes are either 0 or 2, heterozygotes are 1). plink data format import is under development.

Example data is stored in the stickSNPs object. snpR generally assumes that all SNP datasets have at least one column of metadata, and may break if this is not true.

## SNP filtering

The filter_snps function can be used to filter poorly sequenced individuals and loci, remove SNPs with a low minor allele frequency either overall or all populations, remove highly heterozygous SNPs (which are likely sourced from duplicated genomic regions), and remove non-biallelic SNPs.

Here, we will filter out all loci with a minor allele frequency below 0.05 in all populations, loci with a heterozygote frequency above 0.6, that are not bi-allelic, that are non-polymorphic, or that are sequenced in less than half of the individuals. We will also remove all individuals that are genotyped at less than half of the remaining loci, then quickly re-check that all loci are still polymophic.

In order to do any functions that require population information, we first need to make a table of population information:

```{r}
pops <- table(substr(colnames(stickSNPs[,4:ncol(stickSNPs)]), 1, 3)) # this produces a table of the number of individuals in each population. Individuals must be sorted in the order they are given in this table!

pops


```

Now, we can run the filterin command.

```{r, results = "hide"}
filt_snps <- filter_snps(x = stickSNPs,
                         ecs = 3, # how many metadata columns are there?
                         maf = 0.05, # what is the minimum minor allele frequency to keep?
                         hf_hets = 0.55, # what is the maximum heterozygote frequency to keep?
                         min_ind =  (ncol(stickSNPs) - 3)/2, # remove all loci sequenced at less than half of the individuals.
                         min_loci = .5, # remove all individuals sequenced at less than half of the loci
                         re_run = "partial", # tell filter_snps to recheck that all loci are polymorphic after removing individuals. Could set to "full" to re-check maf and heterozygote frequency, or FALSE to skip.
                         pop = pops, # tell filter_snps that we want to keep all loci with a maf above 0.1 in at least one population.
                         non_poly = T, # we want to remove non-polymorphic loci
                         bi_al = T, # we want to remove non bi-allelic loci
                         mDat = "NN") # missing genotypes are listed as "NN"
```


## PCA and tSNE plots

A common first analytical step for new data is to run a PCA to look for any evidence of population structure/sequencing errors. snpR has a function to do this in a streamlined way. We'll also make a t-stochastic neighbor embedding plot as well. This is a machine learning method that compresses more PCA axis onto a single two dimensional plot, and can be really nice for showing higher-order structure such as family groups in pedigree data.

To do either of these, we need to first condense the data into a purely numeric form. snpR has support for either allele presence/absense (pa) or (upcoming) a relatedness matrix. First, we'll convert to pa:

```{r, results="hide"}
# Convert to allele presence/absence
pa <- format_snps(filt_snps, ecs = 3, output = "pa") 
```

Which looks like this:

```{r, echo=FALSE}
head(pa)[,1:10]
```


Note that a PCA cannot be constructed with missing data, so we interploate with the average number of each allele across all individuals.

Both the PCA and tSNE plotting functions can work with a column of population IDs (as well as one additional info column, such as sex). First, we'll bind a pop ID column to the pa dataset.

```{r}
# add population info
pa <- cbind(pop = substr(pa$samp, 1, 3), pa)

head(pa)[,1:10]

```

Next, we'll use the PCAfromPA function to make a plot.

```{r}
# make a PCA plot
pca <- PCAfromPA(x = pa, ecs = 2, 
                 plot.vars = "pop", # name of the columns to plot in different colors. Can give up to 2.
                 c.dup = T, # should the dataset be checked for any duplicate individuals? Usually not needed, but a good check to run.
                 do.plot = T)

# view the plot
pca$plot
```


Note that we can also filter out poorly sequenced individuals before plotting, since these will all end up grouping in the middle of the plot due to interpolation of their missing data. To do so, we first make a vector of the counts of sequenced loci per individual:

```{r}
# make a vector of the counts of sequenced loci per individual
counts <- colSums(ifelse(filt_snps[,-c(1:3)] == "NN", 0, 1))

```

Then use the PCAfromPA function to plot, with a few extra arguments to filter out poorly sequenced individuals.

```{r}
p <- PCAfromPA(x = pa, ecs = 2, plot.vars = "pop", c.dup = T, 
                 mc = 600, # minimum count of sequenced loci to plot
                 counts = counts) # provide the vector of counts.

# view the plot, should be the same!
pca$plot
```


We can also do a tSNE plot. This function takes the same arguments, although you must also provide parameters for the tSNE algorithm. This requires the mmtsne and Rtsne packages. To do so, we use the tSNEfromPA() function.

```{r, results="hide"}
# do a t-SNE plot

tsne <- tSNEfromPA(x = pa, ecs = 2, plot.vars = "pop", c.dup = T,
                   initial_dims = 100, # how many initial PCA dimensions should the t-SNE consider?
                   iter = 500) # how many optimization iterations should be run?

```

Which produces:

```{r, echo=FALSE}
tsne$plot
```

Note that this plot tends to split everything into two troups, which are probably male and female samples! There are other parameters that can also be tweaked in the t-SNE function, such as perplexity and theta. For more information, check out the documentation for Rtsne::Rtsne.

The tSNEfromPA() function can also filter poorly sequenced individuals, using the same arugments as before.


## Calculate $\pi$, Ho, and check for private alleles.

$\pi$, Ho, and the number of private alleles are easy to calculate with snpR. In order to calculate $\pi$, we'll need to first conver to allele count format, which is the other main format used by snpR. This format is essentially identical to the format used by Bayescan and a few other pieces of software.

```{r, results="hide"}
# convert to ac. Note that we need to give it the pop information from earlier!
ac <- format_snps(filt_snps, 3, output = "ac", pop = pops)
```

The result looks like this:

```{r, echo=FALSE}
# view:
head(ac)

```

This format has SNP metadata, followed by the total count of sequenced alleles, the number of possible alleles (should be 2 for all loci!), and the count of each allele for each SNP in each population.

From here, $\pi calculation is straightforward:

```{r}
# calculate pi
pi <- calc_pi(ac, ecs = 3)

# the result:
head(pi)

```

This returns pi for each SNP/pop combination in the order given in ac. To calculate Ho, we use the usual character formatted data:

```{r}
# calculate Ho, note that we again provide pop info.
ho <- calc_Ho(x = filt_snps, ecs = 3, pop = pops)

# the result:
head(ho)
```

This will tell us the observed heterozygosity at each SNP in each population. Checking for private alleles is equally straightforward.

```{r}
# check for private alleles, uses the ac format:
pr.a <- check_private(x = ac, ecs = 3)

# view the result:
head(pr.a)

```

Any 1s indicate a private allele in the corresponding population in the corresponding locus. In this case, there are no private alleles, the populations are too recently diverged.

## Pairwise Fst calculation

snpR can calculate pairwise Fst using a few approaches. Here, we'll use Wier and Cockerham (1984)'s method to calculate pairwise Fst between each pair of populations for each SNP.

```{r}
pairwise.fst <- calc_pairwise_Fst(x = ac, ecs = 3, do.nk = T, # should we also count up the number of sequenced individuals for each locus in each pair of populations?
                                  method = "WC", # specifying that we want to use the Wier and Cockerham 1984 method.
                                  char.dat = filt_snps, pop = pops, c.d.ecs = 3) # we can re-provide this info so that the function can call calc_Ho for us. Alternatively, we could bind a Ho column to the dataset, in which case this can be skipped.

# View the Fst results:
head(pairwise.fst$FST)

# View the number of sequenced individuals per locus (nk) in each pair of populations
head(pairwise.fst$nk)
```

There are a handful of other Fst methods available in calc_pairwise_Fst. Check out the function documentation for details.

## Do Gaussian Smoothing

snpR has a tool to sliding window smooth parameters using a Gaussian kernal, splitting by any number of different variables. Here, we'll smooth $\pi, Ho, and pairwise FST, splitting by population. We'll weight each SNPs contribution to the window mean by their sequencing depth.

This function can smooth multiple parameters at a time! We'll do FST and the other stats seperately, since they need to be weighted differently (since less genotypes are used to calculate each FST score--only those in the two pops being compared).

```{r, results="hide"}
# collect pi, ho, and nk data.

# first, we'll melt the observed heterozygosity data into long form
mho <- reshape2::melt(ho, id.vars = colnames(ho)[1:3])
colnames(mho)[4:5] <- c("pop", "Ho")

# then we'll bind things together. Everything should be in the same order, but the data could be sorted or merged to make sure if wanted. nk  can be taken from our ac data:
s.dat <- cbind(mho, pi = pi$pi, nk = ac$n_total)


# finally, we can smooth
s_piho <- s_ave_multi(s.dat, parms = c("Ho", "pi"), # which variables to we smooth? 
                    sigma = 200, # how big are our windows, in kb?
                    ws = 50, # how much do we slide each window, in kb?
                    nk = T, # are we weighting by nk?
                    levs = c("group", "pop")) # which levels are we splitting the smoothing by?

```

The resulting data.frame has the smoothed averages for both stats for each window.

```{r}
head(s_piho)
```


Next, we'll do FST:

```{r, results="hide"}
# First, melt the data down:

mfst <- reshape2::melt(pairwise.fst$FST, id.vars = colnames(pairwise.fst$FST)[1:3])
colnames(mfst)[4:5] <- c("pop", "FST")

# next, melt the nk data down:
mnk <- reshape2::melt(pairwise.fst$nk, id.vars = colnames(pairwise.fst$nk)[1:3])
colnames(mnk)[4:5] <- c("pop", "nk")

# bind them together:
mfst <- cbind(mfst, nk = mnk$nk)

# return pop to a character variable:
mfst$pop <- as.character(mfst$pop)

# and smooth
s_FST <- s_ave_multi(mfst, parms = "FST", sigma = 200, ws = 50, nk = T, levs = c("group", "pop"))
```

The result has FST scores for each window for each pair of populations:

```{r}
head(s_FST)
```


## Plot the Smoothed Parameters

Next, we want to plot these variables. We'll use the ggplot2 package, and start with Ho:

```{r}
# Plot Ho, pi works the same way!
ggplot(s_piho, aes(x = position, y = smoothed_Ho, color = pop)) + geom_line() + theme_bw() +
  facet_wrap(~group, scales = "free_x") # facet wrap on group to split by linkage group/chromosome.
```

Then we'll do FST, but restrict to one linkage group to save some space.

```{r}

ggplot(s_FST[s_FST$group == "groupIX",], aes(x = position, y = smoothed_FST, color = pop)) + geom_line() + theme_bw()
```

Note that these aren't particularly interesting plots in this case, since the dataset is very low SNP resolution!

## Calculate Pairwise LD

Lastly, we'll calculate pairwise LD for one population. This will calculate the r2, Dprime, and a p-value for each pair of SNPs. We can specify that we want to split by linkage groups/chromosomes, as usual. By default, this will produce two outputs: a proximity table and a matrix of pairwise LD for each level for each statistic.

```{r, results="hide"}
# subset out the OPL data
OPL <- cbind(filt_snps[,1:3], filt_snps[,grepl("OPL", colnames(filt_snps))])

# run the LD function.
LD <- LD_full_pairwise(OPL, ecs = 3, levels = "group")
```

Note that the par argument can be used to run this in parallel via the doParallel and foreach packages. The proximity table can be used to make plots of proximity vs LD:

```{r}
# View the proximity table (using tail instead of head, since head has a bunch of rows with missing LD scores).
tail(LD$prox)

ggplot(LD$prox, aes(x = proximity, y = rsq)) + geom_point() + theme_bw()
```

The other output can be used to visualize LD on a per-LG basis, using a built in plotting function:

```{r}
# plot LD across LG IX:
LD_plot <- LD_pairwise_heatmap(LD$groupIX$rsq)

# View the result
LD_plot$plot

```

